%% LyX 2.4.0~RC3 created this file.  For more info, see https://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[american]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{babel}
\begin{document}
\begin{enumerate}
\item I'm working on a code that reads a dynare file (of a linear model).
It can be any text file (so dynare is not fundamental). The idea is
that, I read this fle create a json file with the equations written
for t and t+1 as will be expected by Klein's method. The model has
lead and lags of long horizon so I need to create auxiliary equations
to accommodate this feature. After creating the json file I take the
derivatives of the equation with respect to the variables using analytical
methods and save the jacobbian's in the file that letter is loaded
in memory. The procedure loads these files and evaluate them a parameter
value and call klein's solution method. The solution is working fine. 
\item Tyhe next task is to build a state space representation for the kalman
filter. The way I'm doing this is 

$s_{t+1}=Ps_{t}$

$c_{t}=Fs_{t}$

For simplicity it is easier to split the matrices of the system taking
into account the kind of variable we have (endogenous states, exogenous
state, and controls). 
\item When computing the jacobbian of the model equations variables are
ordered as follows 
\begin{verbatim}
variables = self.state_variables + self.control_variables
\end{verbatim}
where 
\begin{verbatim}
self.state_variables = endogenous_states + exo_with_shocks + exo_without_shocks
\end{verbatim}
So we can use this order to group variables in the F and P matrices
cumming from Klein solution

Lets call $c_{t}$ controls, $k_{t}$ endogenous states and $z_{t}$
exogenous states. That $c_{t}$ is the vector containing self.control\_variables,
$k_{t}$ a vector containing endogenous\_states and $z_{t}$ ordered
as exo\_with\_shocks + exo\_without\_shocks. With this notation is
possible to expressed Klein's solution as 

\[
\left(\begin{array}{c}
k_{t+1}\\
z_{t+1}
\end{array}\right)=\left(\begin{array}{cc}
P_{kk} & P_{kz}\\
0 & P_{zz}
\end{array}\right)\left(\begin{array}{c}
k_{t}\\
z_{t}
\end{array}\right)
\]

\[
c_{t}=\left(\begin{array}{cc}
F_{ck} & F_{cz}\end{array}\right)\left(\begin{array}{c}
k_{t}\\
z_{t}
\end{array}\right)
\]
so that the state space representation would be 
\begin{align*}
k_{t+1} & =P_{kk}k_{t}+P_{kz}z_{t}\\
z_{t+1} & =P_{zz}z_{t}+R\epsilon_{t+1}\\
c_{t} & =F_{ck}k_{t}+F_{cz}z_{t}
\end{align*}

where $\epsilon_{t+1}$ is the vector of shocks consistent with self.varexo\_list.
R is a selection matrix that tells how each shock affects the $z_{t}$.
Given the information on the parser $z_{t}$ follows a particular
order and each variable has it own shock. Here the issue is that some
exogenous states may have more than one lag and hence in the representation
they imply more states (current and lag). Only current states will
have shock. This is typical of a companion form representation of
AR process.
\item To build the state space I'm lagging the equation for $z$ and recomputing
the system 

\begin{align*}
k_{t+1} & =P_{kk}k_{t}+P_{kz}P_{zz}z_{t-1}+P_{kz}R\epsilon_{t}\\
c_{t} & =F_{ck}k_{t}+F_{cz}P_{zz}z_{t-1}+F_{cz}R\epsilon_{t}\\
z_{t} & =P_{zz}z_{t-1}+R\epsilon_{t}
\end{align*}
so the state space can be written as

\[
\left[\begin{array}{c}
k_{t+1}\\
c_{t}\\
z
\end{array}\right]=\left[\begin{array}{ccc}
P_{kk} & 0 & P_{kz}P_{zz}\\
F_{ck} & 0 & F_{cz}P_{zz}\\
0 & 0 & P_{zz}
\end{array}\right]\left[\begin{array}{c}
k_{t}\\
c_{t-1}\\
z_{t-1}
\end{array}\right]+\left[\begin{array}{c}
P_{kz}R\\
F_{cz}R\\
R
\end{array}\right]\epsilon_{t}
\]
and the state-space can be written as 

\begin{align*}
y_{t} & =Hw_{t}\\
w_{t} & =Aw_{t-1}+B\epsilon_{t}
\end{align*}
\\

One feature is that some of the exogenous variables may have more
that one lag. Say you have to exogenos variables 
\[
z_{1t}=\rho_{10}z_{1t-1}+\rho_{11}z_{1t-2}+\epsilon_{t}^{z1}
\]

\[
z_{2t}=\rho_{20}z_{2t-1}+\epsilon_{t}^{z2}
\]
in this case 
\[
z_{t}=\left(\begin{array}{c}
z_{1t}\\
z_{1t-1}\\
z_{2t}
\end{array}\right)=\left[\begin{array}{ccc}
\rho_{10} & \rho_{11} & 0\\
1 & 0 & 0\\
0 & \rho_{20} & 0
\end{array}\right]\left(\begin{array}{c}
z_{1t-1}\\
z_{1t-2}\\
z_{2t-1}
\end{array}\right)+\left[\begin{array}{cc}
1 & 0\\
0 & 0\\
0 & 1
\end{array}\right]\left(\begin{array}{c}
\epsilon_{t}^{z1}\\
\epsilon_{t}^{z2}
\end{array}\right)
\]
where it is clear what R is in the notation above. 
\item In the code full\_code\_includes\_parser.py I'm working on an implementation
that augments the state space by including stochastic trends and also
has other characteristics. 
\begin{enumerate}
\item Only a subset of the variables is observable, as defined by the user
\item The code is written in a way the maximizes efficiency and limits the
regeneration of matrices that are constant across parameter changes.
That is, matrices, or submatrices that remain constant when parameters
are changed. This is to generae a code that is efficient when computing
the likelihood function or carry out mcmc. 
\item The model state space representation remains similar but includes
trends so the number of states is larger by definition. The augmented
state space model should look like
\begin{align*}
y_{t}^{obs} & =HC_{aug}x_{t}^{aug}\\
x_{t}^{aug} & =A_{aug}x_{t-1}^{aug}+B_{aug}\epsilon_{t}^{aug}
\end{align*}
where H: is a selection matrix with zeros and ones (or may be replace
by an index) that selects the rows of $C_{aug}x_{t}^{aug}$ that are
observable, 
\[
A_{aug}=\left[\begin{array}{cc}
A & 0\\
0 & A_{trend}
\end{array}\right]
\]

\[
B_{aug}=\left[\begin{array}{cc}
B & 0\\
0 & B_{trend}
\end{array}\right]
\]
and $\epsilon_{t}^{aug}=\left(\epsilon_{t},\epsilon_{t}^{trends}\right)$. 
\item Not all observable variables have the same trend specification. The
trend specification of a variables can be 
\begin{enumerate}
\item Random walk: 

\[
trend_{t}=trend_{t-1}+\epsilon_{t}^{level}
\]

\item Second difference
\begin{align*}
trend_{t} & =trend_{t-1}+g_{t-1}+\epsilon_{t}^{level}\\
g_{t} & =g_{t-1}+\epsilon_{t}^{growth}
\end{align*}
\item Constant mean

\[
trend_{t}=trend_{t-1}
\]

\end{enumerate}
\item The code is not producing the right IRFs but I think is because, 1)
is not creating the state space representation in an organized for.
I'm adding this information to seek you help and produce a state space
represenation for the augmented model that matches the description
above and repreduces the IRFS accordingly. 
\item In a future specification we may consider situations where the trends
can interact.
\end{enumerate}
\item The code is structure as follows:
\begin{enumerate}
\item DynareParser just reads the file and produce some auxiliary function
and constants needed for the solution
\item ModelSover. Loads files created by the parser and computes the klain
solution 
\item AugmentedState Space creates the augmented representation. 
\end{enumerate}
\item There are several changes needed. ModelSolver has of function not
needed and is missing Klein solution (that is available in the code,
just copy that into the class). Remove all not necesary functions. 
\item Check the augmented class and link it to the model solver. Check the
the filtration is working and the irfs are correct. 
\end{enumerate}

\end{document}
