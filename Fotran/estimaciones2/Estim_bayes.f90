SUBROUTINE ESTIMATEOBJ(ESTIMSIZE,PAR,LOG_L)
  USE PARAMETER_VECTOR_MOD 
  USE PRIOR_MODULE , ONLY : PRIOR_PAR, DIST
  USE MODEL_CONST_MOD, ONLY : NPAR
  IMPLICIT NONE
  INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 60)
  INTEGER , INTENT(IN) :: ESTIMSIZE
  REAL(DP) , INTENT(IN) , DIMENSION(ESTIMSIZE) :: PAR
  REAL(DP), INTENT(OUT) :: LOG_L
  REAL (DP) :: RAT_ERROR
  INTEGER INFO
  REAL(DP) PRIOR,  LOG_KERN
  INTEGER I

  REAL(DP) DIST_BOUNDS
  INTEGER CHECK_BONDS
  EXTERNAL CHECK_BONDS

  !EAL(DP), DIMENSION(sizepar,2) :: PARBOUDS, PRIOR_PAR
  !CHARACTER(LEN =sizepar*4) :: DIST
  
!  print *, "Estoy en ..."
!  print *, par    
  
  !PRIOR
  !PRIOR_PAR(I) = (MEAN(I), VAR(I))
 
  
!   DO I = 1, SIZEPAR
!      WRITE(*, '(2F10.5)'), PRIOR_PAR(I, 1:2)
!   END DO
  
  !DIST = "DGAM"//"DGAM"//"DGAM"//"DIGA"//"DBET"//"DUNI"
  
  !PRIOR INDEPENDIENTE: LOG(P(THETA))=\SUM
  !LB = 1


  INFO = CHECK_BONDS(PAR, ESTIMSIZE ,PARBOUNDS, DIST_BOUNDS)
  IF ( INFO .EQ. 1 )  then 
     !LOG_L = -1000*PRIOR + 10.0E5
     LOG_L = (1+DIST_BOUNDS)*10.0E20
     !PRINT *,'Parameters out of bounds:',DIST_BOUNDS
     RETURN
  END IF


!  PRIOR = 0.0_dp 
!  DO I = 1, ESTIMSIZE
!     !UB = LB + 3     
!     CALL KERNEL_SELECT(PAR(I), PRIOR_PAR(I,1), PRIOR_PAR(I,2), PARBOUNDS(I,1),PARBOUNDS(I,2),LOG_KERN, DIST(I))
!     PRIOR = PRIOR + LOG_KERN
!     !LB = UB + 1
!  END DO
  
  !check bounds
!   DO I = 1, SIZEPAR
!      WRITE(*, '(2F10.5)'),   PARBOUDS(I, 1:2)
!   END DO

 !  INFO = 0
  !print *, info

  

  !PARMODEL(12)=PAR(1) !ETA
  !PARMODEL(28)=PAR(2) !OMEGA
  !PARMODEL(69)=PAR(3) !SIGMA_M
  !PARMODEL(33)=PAR(4) !OMEGA_X
  !PARMODEL(4)=PAR(5) !epsq
  !PARMODEL(43)=PAR(6) !epsq
    
 ! do i=1,estimsize
 ! print*,"par",i,":",par(i)
 ! end do
  CALL LOGLIK_PAT(PAR,LOG_L,INFO)    
!   PRINT *,"LOG_L=",LOG_L
  
  !! Incluir la información de largo plazo
  !PRIOR = PRIOR - 
!  print *, "prior=", PRIOR
!  LOG_L = (LOG_L - PRIOR)
  !if (LOG_L<-1e10) then
  !   PRINT *,"PAR=",PAR
  !ENDIF 
!   PRINT *,"PRIOR=",PRIOR

   
  
END SUBROUTINE ESTIMATEOBJ


! FUNCTION CHECK_BONDS(PAR, SIZEPAR,PARBOUDS)
!   IMPLICIT NONE 
!   INTEGER SIZEPAR
!   INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 60)
!   REAL(DP) , DIMENSION(SIZEPAR) , INTENT(IN) :: PAR
!   REAL(DP), DIMENSION(SIZEPAR, 2), INTENT(IN) :: PARBOUDS
!   INTEGER i , CHECK_BONDS
  
!   CHECK_BONDS = 0
!   DO I = 1, SIZEPAR
!      IF ( ( PAR(I) .LE. PARBOUDS(I,1) ) .OR. ( PAR(I) .GT. PARBOUDS(I,2) )  ) THEN
!         CHECK_BONDS = 1
!      END IF
!   END DO
  
! END FUNCTION CHECK_BONDS


SUBROUTINE KERNEL_SELECT(X, MEAN, VAR, LIMINF, LIMSUP, LOG_KERN, DIST)
  IMPLICIT NONE
  INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 60)
  REAL(DP) , INTENT(IN) :: X, MEAN, VAR, LIMINF, LIMSUP
  REAL(DP) , INTENT(OUT) :: LOG_KERN
  
  CHARACTER(LEN =4), intent(in) ::  DIST

  IF ( DIST == 'dbet' .OR. DIST =='DBET' ) THEN 
     CALL KERNEL_BETA(X, MEAN, VAR, LIMINF, LIMSUP, LOG_KERN)
     RETURN
  END IF

  IF ( DIST == 'dgam' .OR. DIST =='DGAM' ) THEN 
     CALL KERNEL_GAMMA(X, MEAN, VAR, LOG_KERN)
     RETURN
  END IF

  IF ( DIST == 'diga' .OR. DIST =='DIGA' ) THEN 
     CALL KERNEL_IGAMMA(X, MEAN, VAR, LOG_KERN)
     RETURN
  END IF
  
  IF ( DIST == 'duni' .OR. DIST == 'DUNI' ) THEN 
     CALL KERNEL_UNIFORME(X, MEAN, VAR, LOG_KERN)
     RETURN
  END IF
  
END SUBROUTINE KERNEL_SELECT
  

  
SUBROUTINE KERNEL_BETA(X, MEAN, VAR, A, B, LOG_KERN)
  IMPLICIT NONE  
  INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 60)
  REAL(DP) , INTENT(IN) :: X, MEAN, VAR, A, B
  REAL(DP) , INTENT(OUT) :: LOG_KERN
  REAL(DP) THETA, ALPHA
  
  ALPHA =  -(((MEAN-A)/(B-A))*(VAR/(B-A)**2)  + ((MEAN-A)/(B-A))**3.0 - &
            &((MEAN-A)/(B-A))**2.0)/(VAR/(B-A)**2)
  THETA = ((((MEAN-A)/(B-A))-1)*(VAR/(B-A)**2)  + ((MEAN-A)/(B-A))**3.0- &
            &2*((MEAN-A)/(B-A))**2.0 + ((MEAN-A)/(B-A)))/(VAR/(B-A)**2)
 ! PRINT *,"theta=",THETA  
  LOG_KERN = (ALPHA-1.0)*LOG((X-A)/(B-A)) + (THETA - 1.0)*LOG(1-(X-A)/(B-A))
!  PRINT *,"BETA=",LOG_KERN
  RETURN
END SUBROUTINE KERNEL_BETA

SUBROUTINE KERNEL_UNIFORME(X, MEAN, VAR, LOG_KERN)
  IMPLICIT NONE
  INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 60)
  REAL(DP) , INTENT(IN) :: X, MEAN, VAR
  REAL(DP) , INTENT(OUT) :: LOG_KERN
  REAL(DP) THETA, ALPHA
  REAL(DP) , PARAMETER :: SQRT3 = SQRT(3.0_DP) , ZERO = EPSILON(1.0_DP)
  REAL(DP) SQRT_VAR
  
  SQRT_VAR = SQRT(VAR)   
  ALPHA = MEAN-SQRT3*SQRT_VAR 
  THETA = SQRT3*SQRT_VAR+MEAN
  
  IF ( ( X .LT. THETA ) .AND. ( X .GT. ALPHA ) ) THEN 
     LOG_KERN = LOG(1.0_DP/(THETA-ALPHA))
  ELSE
     LOG_KERN = LOG(ZERO)
  END IF

  RETURN
END SUBROUTINE KERNEL_UNIFORME


SUBROUTINE KERNEL_GAMMA(X, MEAN, VAR, LOG_KERN)
  IMPLICIT NONE  
  INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 60)
  REAL(DP) , INTENT(IN) :: X, MEAN, VAR
  REAL(DP) , INTENT(OUT) :: LOG_KERN
  REAL(DP) THETA, ALPHA
  
  THETA = VAR/MEAN
  ALPHA = MEAN/THETA  
  
  LOG_KERN = (ALPHA-1.0)*LOG(X)- X/THETA
  RETURN 
  
END SUBROUTINE KERNEL_GAMMA


SUBROUTINE KERNEL_IGAMMA(X, MEAN, VAR, LOG_KERN)
  IMPLICIT NONE
  INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 60)
  REAL(DP) , INTENT(IN) :: X, MEAN, VAR
  REAL(DP) , INTENT(OUT) :: LOG_KERN
  REAL(DP) THETA, ALPHA
  
 ! ALPHA = VAR/MEAN**2.0 + 2.0 !Pilas esto está mal
 ! THETA = MEAN*(ALPHA -1)
  
 ! LOG_KERN =  (ALPHA+1.0)*(1/X)- THETA/X  ! Esto también
   
   ALPHA = MEAN**2.0/VAR + 2.0
   THETA = MEAN*(ALPHA -1)  
   LOG_KERN =  -(ALPHA+1.0)*LOG(X) - THETA/X
 !  PRINT *,"GAMAINV=",LOG_KERN
  RETURN 
  
END SUBROUTINE KERNEL_IGAMMA

SUBROUTINE KERNEL_NORMAL(X, MEAN, VAR, LOG_KERN)
  IMPLICIT NONE
  INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(12, 60)
  REAL(DP) , INTENT(IN) :: X, MEAN, VAR
  REAL(DP) , INTENT(OUT) :: LOG_KERN

  LOG_KERN = -0.5*log(var) - 0.5*(x - mean)**2/var
  
END SUBROUTINE KERNEL_NORMAL
    
  
